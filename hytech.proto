syntax = "proto3";

package hytech;

enum em_voltage {
     = 0;
     = 1;
     = 2;
     = 3;
}

enum ecu_state {
    STARTUP = 0;
    TRACTIVE_SYSTEM_NOT_ACTIVE = 1;
    TRACTIVE_SYSTEM_ACTIVE = 2;
    ENABLING_INVERTER = 3;
    WAITING_READY_TO_DRIVE_SOUND = 4;
    READY_TO_DRIVE = 5;
}

enum dial_state {
    MODE_0 = 0;
    MODE_1 = 1;
    MODE_2 = 2;
    MODE_3 = 3;
    MODE_4 = 4;
    MODE_5 = 5;
}

enum vn_gps_status {
    NO_FIX = 0;
    TIME_ONLY = 1;
    FIX_2D = 2;
    FIX_3D = 3;
}

enum torque_controller_mux_status {
    NO_ERROR = 0;
    ERROR_SPEED_DIFF_TOO_HIGH = 1;
    ERROR_TORQUE_DIFF_TOO_HIGH = 2;
    ERROR_CONTROLLER_INDEX_OUT_OF_BOUNDS = 3;
    ERROR_CONTROLLER_NULL_POINTER = 4;
}

enum steering_system_status {
     = 0;
     = 1;
     = 2;
     = 3;
}

enum steering_encoder_status {
     = 0;
     = 1;
     = 2;
}

message izze_ir_temps {
    int32 izze_brake_IR_temp_1 = 1;
    int32 izze_brake_IR_temp_2 = 2;
    int32 izze_brake_IR_temp_3 = 3;
    int32 izze_brake_IR_temp_4 = 4;
}

message bms_balancing_status {
    int32 group_id = 1;
    bool cell_1_balancing_status = 2;
    bool cell_2_balancing_status = 3;
    bool cell_3_balancing_status = 4;
    bool cell_4_balancing_status = 5;
    bool cell_5_balancing_status = 6;
    bool cell_6_balancing_status = 7;
    bool cell_7_balancing_status = 8;
    bool cell_8_balancing_status = 9;
    bool cell_9_balancing_status = 10;
    bool cell_10_balancing_status = 11;
    bool cell_11_balancing_status = 12;
    bool cell_12_balancing_status = 13;
    bool cell_13_balancing_status = 14;
    bool cell_14_balancing_status = 15;
    bool cell_15_balancing_status = 16;
    bool cell_16_balancing_status = 17;
    bool cell_17_balancing_status = 18;
    bool cell_18_balancing_status = 19;
    bool cell_19_balancing_status = 20;
    bool cell_20_balancing_status = 21;
    bool cell_21_balancing_status = 22;
    bool cell_22_balancing_status = 23;
    bool cell_23_balancing_status = 24;
    bool cell_24_balancing_status = 25;
    bool cell_25_balancing_status = 26;
    bool cell_26_balancing_status = 27;
    bool cell_27_balancing_status = 28;
    bool cell_28_balancing_status = 29;
    bool cell_29_balancing_status = 30;
    bool cell_30_balancing_status = 31;
    bool cell_31_balancing_status = 32;
    bool cell_32_balancing_status = 33;
    bool cell_33_balancing_status = 34;
    bool cell_34_balancing_status = 35;
    bool cell_35_balancing_status = 36;
    bool cell_36_balancing_status = 37;
    bool cell_37_balancing_status = 38;
    bool cell_38_balancing_status = 39;
    bool cell_39_balancing_status = 40;
    bool cell_40_balancing_status = 41;
    bool cell_41_balancing_status = 42;
    bool cell_42_balancing_status = 43;
    bool cell_43_balancing_status = 44;
    bool cell_44_balancing_status = 45;
    bool cell_45_balancing_status = 46;
    bool cell_46_balancing_status = 47;
    bool cell_47_balancing_status = 48;
    bool cell_48_balancing_status = 49;
    bool cell_49_balancing_status = 50;
    bool cell_50_balancing_status = 51;
    bool cell_51_balancing_status = 52;
    bool cell_52_balancing_status = 53;
    bool cell_53_balancing_status = 54;
    bool cell_54_balancing_status = 55;
    bool cell_55_balancing_status = 56;
    bool cell_56_balancing_status = 57;
    bool cell_57_balancing_status = 58;
    bool cell_58_balancing_status = 59;
    bool cell_59_balancing_status = 60;
    bool cell_60_balancing_status = 61;
}

/*
 * UNUSED message to send data on the BMS current draw.
*/
message bms_coulomb_counts {
    float total_charge = 1; // UNUSED SIGNAL. See legacy AMS firmware (code-2024) for usage.
    float total_discharge = 2; // UNUSED SIGNAL. See legacy AMS firmware (code-2024) for usage.
}

message bms_detailed_temps {
    int32 group_id = 1;
    int32 ic_id = 2;
    float thermistor_id_0 = 3;
    float thermistor_id_1 = 4;
    float thermistor_id_2 = 5;
}

message bms_detailed_voltages {
    int32 group_id = 1;
    int32 ic_id = 2;
    float voltage_0 = 3;
    float voltage_1 = 4;
    float voltage_2 = 5;
}

message bms_onboard_detailed_temps {
    int32 ic_id = 1;
    float temp_0 = 2;
    float temp_1 = 3;
}

message bms_onboard_temps {
    float average_temp = 1;
    float low_temp = 2;
    float high_temp = 3;
}

message bms_status {
    int32 state = 1;
    bool overvoltage_error = 2; // Whether or not the energy meter is reading an over-voltage error.
    bool undervoltage_error = 3;
    bool total_voltage_high_error = 4;
    bool discharge_overcurrent_error = 5;
    bool charge_overcurrent_error = 6;
    bool discharge_overtemp_error = 7;
    bool charge_overtemp_error = 8;
    bool undertemp_error = 9;
    bool overtemp_error = 10;
    float current = 11;
    bool shutdown_g_above_threshold_error = 12;
    bool shutdown_h_above_threshold_error = 13;
}

message bms_temps {
    float average_temp = 1;
    float low_temp = 2;
    float high_temp = 3;
}

message bms_voltages {
    float average_voltage = 1;
    float low_voltage = 2;
    float high_voltage = 3;
    float total_voltage = 4;
}

message ccu_status {
    bool charger_enabled = 1;
}

message charger_control {
    int32 max_charging_voltage_high = 1; // Unused for any PCAN stuff only for Elcon Charger
    int32 max_charging_voltage_low = 2; // Unused for any PCAN stuff only for Elcon Charger
    int32 max_charging_current_high = 3; // Unused for any PCAN stuff only for Elcon Charger
    int32 max_charging_current_low = 4; // Unused for any PCAN stuff only for Elcon Charger
    int32 control = 5;
}

message charger_data {
    int32 output_dc_voltage_high = 1;
    int32 output_dc_voltage_low = 2;
    int32 output_current_high = 3;
    int32 output_current_low = 4;
    int32 flags = 5;
    int32 input_ac_voltage_high = 6;
    int32 input_ac_voltage_low = 7;
}

/*
 * Contains the voltage and current readings from the Energy Meter. Sent by the AMS.
*/
message em_measurement {
    float em_current = 1; // The current draw, in amps, measured by the Energy Meter.
    float em_voltage = 2; // The voltage, in Volts, measured by the Energy Meter.
}

/*
 * Forwarded directly from the Energy Meter with no modifications. See datasheet for more specifications.
*/
message em_status {
    int32 voltage_gain = 1; // This selects the "gain" mode for the EM voltage measurements. The specific multipliers for each gain mode are configured with the EMD Tool.
    int32 current_gain = 2; // This selects the "gain" mode for the EM current measurements. The specific multipliers for each gain mode are configured with the EMD Tool.
    bool overvoltage_error = 3; // Whether or not the energy meter is reading an over-voltage error.
    bool overpower_error = 4; // Whether or not the Energy Meter is reading an over-power error.
    bool logging = 5; // Whether or not the energy meter is currently logging data.
}

message mc1_energy {
    int32 dc_bus_voltage = 1;
    int32 motor_power = 2; // Made up units from AMK
    int32 feedback_torque = 3; // random made up AMK units
}

message mc1_setpoints_command {
    bool inverter_enable = 1;
    bool hv_enable = 2;
    bool driver_enable = 3;
    bool remove_error = 4;
    int32 speed_setpoint_rpm = 5;
    float positive_torque_limit = 6; // Made up units from AMK
    float negative_torque_limit = 7; // AMK made up unit
}

message mc1_status {
    bool system_ready = 1;
    bool error = 2;
    bool warning = 3;
    bool quit_dc_on = 4;
    bool dc_on = 5;
    bool quit_inverter_on = 6;
    bool inverter_on = 7;
    bool derating_on = 8;
    int32 speed_rpm = 9;
    float torque_current = 10;
    int32 magnetizing_current = 11;
}

message mc1_temps {
    float motor_temp = 1;
    float inverter_temp = 2;
    int32 diagnostic_number = 3;
    float igbt_temp = 4;
}

message mc1_torque_command {
    float torque_command = 1; // Made up unit by AMK (consult Shayan)
}

message mc2_energy {
    int32 dc_bus_voltage = 1;
    int32 motor_power = 2; // Made up units from AMK
    int32 feedback_torque = 3; // random made up AMK units
}

message mc2_setpoints_command {
    bool inverter_enable = 1;
    bool hv_enable = 2;
    bool driver_enable = 3;
    bool remove_error = 4;
    int32 speed_setpoint_rpm = 5;
    float positive_torque_limit = 6; // Made up units from AMK
    float negative_torque_limit = 7; // AMK made up unit
}

message mc2_status {
    bool system_ready = 1;
    bool error = 2;
    bool warning = 3;
    bool quit_dc_on = 4;
    bool dc_on = 5;
    bool quit_inverter_on = 6;
    bool inverter_on = 7;
    bool derating_on = 8;
    int32 speed_rpm = 9;
    float torque_current = 10;
    int32 magnetizing_current = 11;
}

message mc2_temps {
    float motor_temp = 1;
    float inverter_temp = 2;
    int32 diagnostic_number = 3;
    float igbt_temp = 4;
}

message mc2_torque_command {
    float torque_command = 1; // Made up unit by AMK (consult Shayan)
}

message mc3_energy {
    int32 dc_bus_voltage = 1;
    int32 motor_power = 2; // Made up units from AMK
    int32 feedback_torque = 3; // random made up AMK units
}

message mc3_setpoints_command {
    bool inverter_enable = 1;
    bool hv_enable = 2;
    bool driver_enable = 3;
    bool remove_error = 4;
    int32 speed_setpoint_rpm = 5;
    float positive_torque_limit = 6; // Made up units from AMK
    float negative_torque_limit = 7; // AMK made up unit
}

message mc3_status {
    bool system_ready = 1;
    bool error = 2;
    bool warning = 3;
    bool quit_dc_on = 4;
    bool dc_on = 5;
    bool quit_inverter_on = 6;
    bool inverter_on = 7;
    bool derating_on = 8;
    int32 speed_rpm = 9;
    float torque_current = 10;
    int32 magnetizing_current = 11;
}

message mc3_temps {
    float motor_temp = 1;
    float inverter_temp = 2;
    int32 diagnostic_number = 3;
    float igbt_temp = 4;
}

message mc3_torque_command {
    float torque_command = 1; // Made up unit by AMK (consult Shayan)
}

message mc4_energy {
    int32 dc_bus_voltage = 1;
    int32 motor_power = 2; // Made up units from AMK
    int32 feedback_torque = 3; // random made up AMK units
}

message mc4_setpoints_command {
    bool inverter_enable = 1;
    bool hv_enable = 2;
    bool driver_enable = 3;
    bool remove_error = 4;
    int32 speed_setpoint_rpm = 5;
    float positive_torque_limit = 6; // Made up units from AMK
    float negative_torque_limit = 7; // AMK made up unit
}

message mc4_status {
    bool system_ready = 1;
    bool error = 2;
    bool warning = 3;
    bool quit_dc_on = 4;
    bool dc_on = 5;
    bool quit_inverter_on = 6;
    bool inverter_on = 7;
    bool derating_on = 8;
    int32 speed_rpm = 9;
    float torque_current = 10;
    int32 magnetizing_current = 11;
}

message mc4_temps {
    float motor_temp = 1;
    float inverter_temp = 2;
    int32 diagnostic_number = 3;
    float igbt_temp = 4;
}

message mc4_torque_command {
    float torque_command = 1; // Made up unit by AMK (consult Shayan)
}

message mcu_analog_readings {
    int32 steering_1 = 1;
    int32 steering_2 = 2;
    int32 hall_effect_current = 3;
    int32 glv_battery_voltage = 4;
}

message mcu_front_pots {
    int32 potentiometer_fl = 1;
    int32 potentiometer_fr = 2;
}

message mcu_load_cells {
    int32 load_cell_fl = 1;
    int32 load_cell_fr = 2;
}

message mcu_pedal_readings {
    float accel_percent_float = 1; // The percentage of accel pedal travel represented by an unsigned float
    float brake_percent_float = 2; // The percentage of accel pedal travel represented by an unsigned float
    float mechanical_brake_percent_float = 3; // The percentage at which mechanical brake activates represented by an unsigned float
}

message brake_pressure_sensor {
    float brake_sensor_analog_read = 1;
}

message mcu_rear_pots {
    int32 potentiometer_rl = 1;
    int32 potentiometer_rr = 2;
}

message mcu_status {
    bool imd_ok_high = 1;
    bool shutdown_b_above_threshold = 2;
    bool bms_ok_high = 3;
    bool shutdown_c_above_threshold = 4;
    bool bspd_ok_high = 5;
    bool shutdown_d_above_threshold = 6;
    bool software_ok_high = 7;
    bool shutdown_e_above_threshold = 8;
    bool mechanical_brake_active = 9;
    bool no_accel_implausibility = 10;
    bool no_brake_implausibility = 11;
    bool brake_pedal_active = 12;
    bool bspd_current_high = 13;
    bool bspd_brake_high = 14;
    bool no_accel_or_brake_implausibility = 15;
    bool drive_buzzer = 16;
    ecu_state ecu_state = 17;
    bool inverter_error = 18;
    bool energy_meter_present = 19;
    bool software_ok = 20;
    bool launch_control_active = 21;
    int32 pack_charge_critical = 22;
    int32 drive_mode = 23; // The current drive mode on the ECU irrespective of dial mapping
    int32 max_torque = 24;
    int32 torque_mode = 25; // torque mode
    float distance_traveled_m = 26;
}

message dashboard_state {
    bool start_button = 1;
    bool mark_button = 2;
    bool mode_button = 3;
    bool motor_controller_cycle_button = 4;
    bool launch_ctrl_button = 5;
    bool torque_mode_button = 6;
    bool led_dimmer_button = 7;
    bool left_shifter_button = 8;
    bool right_shifter_button = 9;
    bool shutdown_h_above_threshold = 10;
    bool ssok_above_threshold = 11;
    bool drive_buzzer = 12;
    int32 tcu_recording_state = 13; // The current state of TCU data recording (off, requested,on,saving)
    dial_state dial_state = 14;
}

message dashboard_mcu_state {
    int32 bots_led = 1;
    int32 launch_control_led = 2;
    int32 mode_led = 3;
    int32 mechanical_brake_led = 4;
    int32 cockpit_brb_led = 5;
    int32 inertia_status_led = 6;
    int32 start_status_led = 7;
    int32 motor_controller_error_led = 8;
    int32 imd_led = 9;
    int32 ams_led = 10;
    bool drive_buzzer = 11;
    int32 glv_led = 12; // glv led has a value from 0 to 255 representing a percentage that can be displayed on dashboard as a gradient between two colors
    int32 pack_charge_led = 13; // pack charge led has a value from 0 to 255 representing a percentage that can be displayed on dashboard as a gradient between two colors
    dial_state dial_state = 14;
}

/*
 * The TCU_LAP_TIMES message contains the best and previous lap times to the dashboard as calculated by the TCU or manually input by the pit crew. It also relays the current state of the TCU's clock to the dashboard so that it can run an approximate stopwatc
*/
message tcu_lap_times {
    int32 best_lap_time = 1;
    int32 prev_lap_time = 2;
    int32 lap_clock_state = 3;
}

/*
 * TCU_DRIVER_MSG contains a signal that corresponds to a preset list of messages on the dashboard. It also includes two variables to customize the contents of the message with numerical values. It also includes the target lap time which is determined by the
*/
message tcu_driver_msg {
    int32 driver_message = 1; // corresponds to a pre-set list of driver messages on the dashboard that the TCU can request to be displayed in event of comms failure
    int32 driver_msg_var_1 = 2;
    int32 driver_msg_var_2 = 3;
    int32 target_lap_time = 4; // target lap time is the time determined by the pit crew that the driver should aim for. mostly useful for guiding the driver in endurance races.
}

message lf_ttpms_1 {
    int32 LF_TTPMS_SN = 1;
    int32 LF_TTPMS_BAT_V = 2;
    int32 LF_TTPMS_P = 3;
    int32 LF_TTPMS_P_GAUGE = 4;
}

message lf_ttpms_2 {
    float LF_TTPMS_T1 = 1;
    float LF_TTPMS_T2 = 2;
    float LF_TTPMS_T3 = 3;
    float LF_TTPMS_T4 = 4;
}

message lf_ttpms_3 {
    float LF_TTPMS_T5 = 1;
    float LF_TTPMS_T6 = 2;
    float LF_TTPMS_T7 = 3;
    float LF_TTPMS_T8 = 4;
}

message lf_ttpms_4 {
    float LF_TTPMS_T9 = 1;
    float LF_TTPMS_T10 = 2;
    float LF_TTPMS_T11 = 3;
    float LF_TTPMS_T12 = 4;
}

message lf_ttpms_5 {
    float LF_TTPMS_T13 = 1;
    float LF_TTPMS_T14 = 2;
    float LF_TTPMS_T15 = 3;
    float LF_TTPMS_T16 = 4;
}

message lf_ttpms_6 {
    int32 LF_TTPMS_TC = 1;
    int32 LF_TTPMS_RSSI = 2;
    float LF_TTPMS_T = 3;
    int32 LF_TTPMS_NODE_ID = 4;
}

message lr_ttpms_1 {
    int32 LR_TTPMS_SN = 1; // Serial Number
    int32 LR_TTPMS_BAT_V = 2;
    int32 LR_TTPMS_P = 3;
    int32 LR_TTPMS_P_GAUGE = 4;
}

message lr_ttpms_2 {
    float LR_TTPMS_T1 = 1;
    float LR_TTPMS_T2 = 2;
    float LR_TTPMS_T3 = 3;
    float LR_TTPMS_T4 = 4;
}

message lr_ttpms_3 {
    float LR_TTPMS_T5 = 1;
    float LR_TTPMS_T6 = 2;
    float LR_TTPMS_T7 = 3;
    float LR_TTPMS_T8 = 4;
}

message lr_ttpms_4 {
    float LR_TTPMS_T9 = 1;
    float LR_TTPMS_T10 = 2;
    float LR_TTPMS_T11 = 3;
    float LR_TTPMS_T12 = 4;
}

message lr_ttpms_5 {
    float LR_TTPMS_T13 = 1;
    float LR_TTPMS_T14 = 2;
    float LR_TTPMS_T15 = 3;
    float LR_TTPMS_T16 = 4;
}

message lr_ttpms_6 {
    int32 LR_TTPMS_TC = 1;
    int32 LR_TTPMS_RSSI = 2;
    float LR_TTPMS_T = 3;
    int32 LR_TTPMS_NODE_ID = 4;
}

message rf_ttpms_1 {
    int32 RF_TTPMS_SN = 1;
    int32 RF_TTPMS_BAT_V = 2;
    int32 RF_TTPMS_P = 3;
    int32 RF_TTPMS_P_GAUGE = 4;
}

message rf_ttpms_2 {
    float RF_TTPMS_T1 = 1;
    float RF_TTPMS_T2 = 2;
    float RF_TTPMS_T3 = 3;
    float RF_TTPMS_T4 = 4;
}

message rf_ttpms_3 {
    float RF_TTPMS_T5 = 1;
    float RF_TTPMS_T6 = 2;
    float RF_TTPMS_T7 = 3;
    float RF_TTPMS_T8 = 4;
}

message rf_ttpms_4 {
    float RF_TTPMS_T9 = 1;
    float RF_TTPMS_T10 = 2;
    float RF_TTPMS_T11 = 3;
    float RF_TTPMS_T12 = 4;
}

message rf_ttpms_5 {
    float RF_TTPMS_T13 = 1;
    float RF_TTPMS_T14 = 2;
    float RF_TTPMS_T15 = 3;
    float RF_TTPMS_T16 = 4;
}

message rf_ttpms_6 {
    int32 RF_TTPMS_TC = 1;
    int32 RF_TTPMS_RSSI = 2;
    float RF_TTPMS_T = 3;
    int32 RF_TTPMS_NODE_ID = 4;
}

message rr_ttpms_1 {
    int32 RR_TTPMS_SN = 1;
    int32 RR_TTPMS_BAT_V = 2;
    int32 RR_TTPMS_P = 3;
    int32 RR_TTPMS_P_GAUGE = 4;
}

message rr_ttpms_2 {
    float RR_TTPMS_T1 = 1;
    float RR_TTPMS_T2 = 2;
    float RR_TTPMS_T3 = 3;
    float RR_TTPMS_T4 = 4;
}

message rr_ttpms_3 {
    float RR_TTPMS_T5 = 1;
    float RR_TTPMS_T6 = 2;
    float RR_TTPMS_T7 = 3;
    float RR_TTPMS_T8 = 4;
}

message rr_ttpms_4 {
    float RR_TTPMS_T9 = 1;
    float RR_TTPMS_T10 = 2;
    float RR_TTPMS_T11 = 3;
    float RR_TTPMS_T12 = 4;
}

message rr_ttpms_5 {
    float RR_TTPMS_T13 = 1;
    float RR_TTPMS_T14 = 2;
    float RR_TTPMS_T15 = 3;
    float RR_TTPMS_T16 = 4;
}

message rr_ttpms_6 {
    int32 RR_TTPMS_TC = 1;
    int32 RR_TTPMS_RSSI = 2;
    float RR_TTPMS_T = 3;
    int32 RR_TTPMS_NODE_ID = 4;
}

message acu_shunt_measurements {
    float current_shunt_read = 1; // The shunt in penthouse; Measures current that goes through the whole tractive system -- used for coulumb counting
    float pack_filtered_read = 2; // Filtered pack voltage
    float ts_out_filtered_read = 3; // Voltage across tractive system
}

message state_of_charge {
    float charge_percentage = 1; // The charge in the accumulator, as a percentage.
    float min_cell_voltage_est = 2; // Lowest-cell-voltage estimate based on the state of charge, according to VOLTAGE_LOOKUP_TABLE. Ex: 87% SoC would display 3.798V.
    float charge_coulombs = 3; // The charge in the accumulator, in Coulombs
}

message penthouse_accum_msg {
    int32 hall_curr_ref = 1;
    int32 hall_curr_signal = 2;
}

message drivetrain_rpms_telem {
    int32 fr_motor_rpm = 1;
    int32 fl_motor_rpm = 2;
    int32 rr_motor_rpm = 3;
    int32 rl_motor_rpm = 4;
}

message drivetrain_err_status_telem {
    int32 mc1_diagnostic_number = 1;
    int32 mc2_diagnostic_number = 2;
    int32 mc3_diagnostic_number = 3;
    int32 mc4_diagnostic_number = 4;
}

message drivetrain_status_telem {
    bool mc1_dc_on = 1;
    bool mc1_derating_on = 2;
    bool mc1_error = 3;
    bool mc1_inverter_on = 4;
    bool mc1_quit_dc = 5;
    bool mc1_quit_inverter_on = 6;
    bool mc1_system_ready = 7;
    bool mc1_warning = 8;
    bool mc2_dc_on = 9;
    bool mc2_derating_on = 10;
    bool mc2_error = 11;
    bool mc2_inverter_on = 12;
    bool mc2_quit_dc = 13;
    bool mc2_quit_inverter_on = 14;
    bool mc2_system_ready = 15;
    bool mc2_warning = 16;
    bool mc3_dc_on = 17;
    bool mc3_derating_on = 18;
    bool mc3_error = 19;
    bool mc3_inverter_on = 20;
    bool mc3_quit_dc = 21;
    bool mc3_quit_inverter_on = 22;
    bool mc3_system_ready = 23;
    bool mc3_warning = 24;
    bool mc4_dc_on = 25;
    bool mc4_derating_on = 26;
    bool mc4_error = 27;
    bool mc4_inverter_on = 28;
    bool mc4_quit_dc = 29;
    bool mc4_quit_inverter_on = 30;
    bool mc4_system_ready = 31;
    bool mc4_warning = 32;
    bool accel_implausible = 33;
    bool brake_implausible = 34;
    int32 brake_percent = 35;
    int32 accel_percent = 36;
}

message sab_thermistors_1 {
    float thermistor_inv1 = 1; // inverter cooling loop temp
    float thermistor_inv2 = 2; // invertor cooling loop tmep
    float thermistor_acc1 = 3; // acculum cooling loop temp
    float thermistor_acc2 = 4; // acculum cooling loop temp
}

message sab_thermistors_2 {
    float thermistor_motor_rl = 1; // Motor cooling loop temperature
    float thermistor_motor_rr = 2; // Motor cooling loop temperature
    float thermistor_pump = 3; // temp of the pump
}

message sab_suspension {
    int32 potentiometer_rl = 1;
    int32 potentiometer_rr = 2;
    int32 load_cell_rl = 3;
    int32 load_cell_rr = 4;
}

message tcu_status {
    int32 shutdown_status = 1;
    int32 tcu_recording_state = 2; // The current state of TCU data recording (off, requested,on,saving)
}

/*
 * Vehicle body velocity measured by VN-300
*/
message vn_vel {
    float vn_body_vel_x = 1;
    float vn_body_vel_y = 2;
    float vn_body_vel_z = 3;
    float vn_vel_uncertainty = 4; // how much error there might be
}

message vn_linear_accel {
    float vn_lin_ins_accel_x = 1; // estimated acceleration of INS
    float vn_lin_ins_accel_y = 2; // estimated acceleration of INS
    float vn_lin_ins_accel_z = 3; // estimated acceleration of INS
}

message vn_linear_accel_uncomp {
    float vn_lin_uncomp_accel_x = 1; // IMU acceleration
    float vn_lin_uncomp_accel_y = 2; // IMU acceleration
    float vn_lin_uncomp_accel_z = 3; // IMU acceleration
}

message vn_ypr {
    float vn_yaw = 1;
    float vn_pitch = 2;
    float vn_roll = 3;
}

message vn_lat_lon {
    float vn_gps_lat = 1;
    float vn_gps_lon = 2;
}

message vn_gps_time_msg {
    uint64 vn_gps_time = 1; // time since start of epoch 1980
}

message vn_status {
    vn_gps_status vn_gps_status = 1;
}

message drivetrain_torque_telem {
    int32 fl_motor_torque = 1;
    int32 fr_motor_torque = 2;
    int32 rl_motor_torque = 3;
    int32 rr_motor_torque = 4;
}

message mcu_suspension {
    int32 potentiometer_fl = 1;
    int32 potentiometer_fr = 2;
    int32 load_cell_fl = 3;
    int32 load_cell_fr = 4;
}

message vn_angular_rate {
    float angular_rate_x = 1;
    float angular_rate_y = 2;
    float angular_rate_z = 3;
}

message vn_ecef_pos_xy {
    float vn_ecef_pos_x = 1; // earth centered earth fixed
    float vn_ecef_pos_y = 2; // earth centered earth fixed
}

message vn_ecef_pos_z_msg {
    float vn_ecef_pos_z = 1; // earth centered earth fixed
}

message mcu_pedal_raw {
    int32 accel_1_raw = 1;
    int32 accel_2_raw = 2;
    int32 brake_1_raw = 3;
    int32 brake_2_raw = 4;
}

message controller_pid_tv_data {
    float controller_input = 1;
    float controller_output = 2;
}

message controller_pid_tv_delta_data {
    float pid_tv_fl_delta = 1;
    float pid_tv_fr_delta = 2;
    float pid_tv_rl_delta = 3;
    float pid_tv_rr_delta = 4;
}

/*
 * MCU's simple torque controller
*/
message tc_simple {
    float torque_request = 1; // The torque request calculated from the accelleration request and the maximum torque
    float front_torque_scale = 2; // the front/rear torque scaling
    float rear_torque_scale = 3; // the front/rear torque scaling
    float front_regen_scale = 4; // the front/rear torque scaling
    float rear_regen_scale = 5; // the front/rear torque scaling
    bool accel_request_state = 6; // The current state of the acceleration request (0 = decelerating, 1 = accelerating)
}

message tc_simple_launch {
    int32 launch_control_state = 1; // The current state of the launch controller (LAUNCH_NOT_READY, LAUNCH_READY, LAUNCHING)
    bool algo_active = 2; // State of whether the launch algorithm has taken over control from the initial launch target
    int32 initial_launch_target = 3; // The initial launch speed target requested by the launch controller
    int32 speed_setpoint_rpm = 4;
}

message vehm_alpha {
    float vehm_alpha_deg_fl = 1;
    float vehm_alpha_deg_fr = 2;
    float vehm_alpha_deg_rl = 3;
    float vehm_alpha_deg_rr = 4;
}

message vehm_beta {
    float vehm_beta_deg = 1;
}

message vehm_long_corner_vel {
    float vehm_long_corner_vel_fl = 1;
    float vehm_long_corner_vel_fr = 2;
    float vehm_long_corner_vel_rl = 3;
    float vehm_long_corner_vel_rr = 4;
}

message vehm_sl {
    float vehm_sl_fl = 1;
    float vehm_sl_fr = 2;
    float vehm_sl_rl = 3;
    float vehm_sl_rr = 4;
}

message vehm_wheel_steer_avg_deg_msg {
    float vehm_wheel_steer_avg_deg = 1;
}

message vehm_kin_des_yaw_rate_rad_s_msg {
    float vehm_kin_desired_yaw_rate_rad_s = 1;
}

message controller_pid_yaw {
    float vehm_kin_desired_yaw_rate_rad_s = 1;
    float controller_yaw_rate_error = 2;
    float controller_yaw_pid_output = 3;
}

message controller_pid_yaw_torque {
    float controller_yaw_torque_fl = 1;
    float controller_yaw_torque_fr = 2;
    float controller_yaw_torque_rl = 3;
    float controller_yaw_torque_rr = 4;
}

message controller_normal_dist {
    float controller_normal_percent_fl = 1;
    float controller_normal_percent_fr = 2;
    float controller_normal_percent_rl = 3;
    float controller_normal_percent_rr = 4;
}

message controller_normal_torque {
    float controller_normal_torque_fl = 1;
    float controller_normal_torque_fr = 2;
    float controller_normal_torque_rl = 3;
    float controller_normal_torque_rr = 4;
}

message controller_power_lim {
    int32 controller_power_lim_status = 1;
    float controller_power_lim_error = 2;
    float controller_power_lim_torque_adj = 3;
}

message controller_power_lim_corner_pow {
    float controller_power_lim_cornerp_fl = 1;
    float controller_power_lim_cornerp_fr = 2;
    float controller_power_lim_cornerp_rl = 3;
    float controller_power_lim_cornerp_rr = 4;
}

message controller_power_lim_torque {
    float controller_power_lim_torque_fl = 1;
    float controller_power_lim_torque_fr = 2;
    float controller_power_lim_torque_rl = 3;
    float controller_power_lim_torque_rr = 4;
}

message controller_boolean {
    bool controller_use_launch = 1;
    bool controller_use_pid_tv = 2;
    bool controller_use_normal_force = 3;
    bool controller_use_pid_power_limit = 4;
    bool controller_use_power_limit = 5;
    bool controller_use_tcs = 6;
    bool controller_use_tcs_lim_yaw_pid = 7;
    bool controller_use_dec_yaw_pid_brake = 8;
    bool controller_use_discontin_brakes = 9;
    bool controller_use_no_regen_5kph = 10;
    bool controller_use_torque_bias = 11;
    bool controller_use_nl_tcs_gain_sche = 12;
    bool controller_use_rpm_tcs_gain_sche = 13;
    bool controller_use_nl_tcs_slipschedu = 14;
}

message controller_torque_setup {
    float controller_initial_torque_req = 1;
    float controller_constrained_torq_req = 2;
    float controller_regen_limit = 3;
    float controller_torque_mode = 4;
    float controller_max_yaw_nl_accel_perc = 5;
    float controller_max_nl_brake_sc_front = 6;
}

message controller_tcs_config {
    float controller_tcs_launch_dead_zone = 1;
    float controller_tcs_launch_vel_thresh = 2;
    float controller_tcs_vel_thresh = 3;
    float controller_tcs_sl_nlperc_star_fr = 4;
    float controller_tcs_sl_nlperc_end_fr = 5;
    float controller_tcs_sl_nlperc_end_rr = 6;
    float controller_tcs_sl_nlperc_star_rr = 7;
}

message controller_tcs_torque {
    float controller_tcs_torque_fl = 1;
    float controller_tcs_torque_fr = 2;
    float controller_tcs_torque_rl = 3;
    float controller_tcs_torque_rr = 4;
}

message controller_tcs_status {
    int32 controller_tcs_status_fl = 1;
    int32 controller_tcs_status_fr = 2;
    int32 controller_tcs_status_rl = 3;
    int32 controller_tcs_status_rr = 4;
}

message controller_tcs_pid_input {
    float controller_tcs_pid_input_fl = 1;
    float controller_tcs_pid_input_fr = 2;
    float controller_tcs_pid_input_rl = 3;
    float controller_tcs_pid_input_rr = 4;
}

message controller_tcs_pid_output {
    float controller_tcs_pid_output_fl = 1;
    float controller_tcs_pid_output_fr = 2;
    float controller_tcs_pid_output_rl = 3;
    float controller_tcs_pid_output_rr = 4;
}

message vehm_wheel_lin_vel {
    float vehm_wheel_lin_vel_fl = 1;
    float vehm_wheel_lin_vel_fr = 2;
    float vehm_wheel_lin_vel_rl = 3;
    float vehm_wheel_lin_vel_rr = 4;
}

message controller_torque_bias {
    float controller_bias_torq_avg_front = 1;
    float controller_bias_torq_avg_rear = 2;
}

message controller_regen_5kph_torque {
    float controller_regen_5kph_torq_fl = 1;
    float controller_regen_5kph_torq_fr = 2;
    float controller_regen_5kph_torq_rl = 3;
    float controller_regen_5kph_torq_rr = 4;
}

message controller_regen_5kph_status {
    bool controller_regen_5kph_status_fl = 1;
    bool controller_regen_5kph_status_fr = 2;
    bool controller_regen_5kph_status_rl = 3;
    bool controller_regen_5kph_status_rr = 4;
}

message controller_yaw_pid_config {
    float controller_yaw_pid_p = 1;
    float controller_yaw_pid_i = 2;
    float controller_yaw_pid_d = 3;
    float controller_yaw_pid_brakes_p = 4;
    float controller_yaw_pid_brakes_i = 5;
    float controller_yaw_pid_brakes_d = 6;
}

message controller_tcs_pid_config {
    float controller_tcs_pid_p_fl = 1;
    float controller_tcs_pid_p_fr = 2;
    float controller_tcs_pid_p_rl = 3;
    float controller_tcs_pid_p_rr = 4;
}

message front_thermistors {
    float thermistor_motor_fl = 1; // Motor cooling loop temperature
    float thermistor_motor_fr = 2; // Motor cooling loop temperature
}

message controller_tcs_saturation_config {
    float controller_tcs_saturation_front = 1;
    float controller_tcs_saturation_rear = 2;
}

message controller_tcs_diff_config {
    float controller_tcs_gen_LRdiff_lowerB = 1;
    float controller_tcs_gen_LRdiff_upperB = 2;
    float controller_tcs_w_steer_lower_b = 3;
    float controller_tcs_w_steer_upper_b = 4;
    float controller_tcs_launch_LRdiff = 5;
}

/*
 * this message will have states internal to the MCU code
*/
message mcu_error_states {
    torque_controller_mux_status torque_controller_mux_status = 1;
}

/*
 * Steering reading; system and sensor status
*/
message steering_system_report {
    float steering_system_angle = 1; // Angle reported by steering system
    float steering_encoder_angle = 2; // Angle measured by upper steering encoder
    float steering_analog_angle = 3; // Angle measured by bottom steering analog sensor
    steering_system_status steering_system_status = 4;
    steering_encoder_status steering_encoder_status = 5;
    bool steering_analog_status = 6; // 0 : good; 1 : clamped
}

message controller_tcs_rpm_sche_config {
    int32 controller_tcs_lower_rpm_front = 1;
    int32 controller_tcs_lower_rpm_rear = 2;
    int32 controller_tcs_upper_rpm_front = 3;
    int32 controller_tcs_upper_rpm_rear = 4;
}

message controller_tcs_nl_sche_config {
    float controller_tcs_endper_nl_front = 1;
    float controller_tcs_endper_nl_rear = 2;
    float controller_tcs_startper_nl_front = 3;
    float controller_tcs_startper_nl_rear = 4;
}

message controller_tcs_config_cont {
    float controller_tcs_lauSL_start_front = 1;
    float controller_tcs_lauSL_end_front = 2;
    float controller_tcs_lauSL_start_rear = 3;
    float controller_tcs_lauSL_end_rear = 4;
    float controller_tcs_SL_start_front = 5;
    float controller_tcs_SL_end_front = 6;
    float controller_tcs_SL_start_rear = 7;
    float controller_tcs_SL_end_rear = 8;
}

message controller_tcs_slip_targets {
    float controller_tcs_slip_target_front = 1;
    float controller_tcs_slip_target_rear = 2;
}

message tcmux_status_report {
    bool speed_above_thresh = 1; // Vehicle speed is above 5 m/s, TCMux does not allow driver to switch mode
    bool torque_delta_above_thresh = 2; // Torque delta between old and new controllers is < 0.5Nm on every wheel
    bool tc_not_ready = 3; // Selected TC not in ready state
    bool steering_system_has_err = 4; // Steering system data in ERROR state
    int32 mode_intended = 5; // TC mode selected by driver
    int32 mode_actual = 6; // actual mode in tcmux
    int32 dash_dial_mode = 7; // Dashboard dial position
    int32 torque_mode = 8; // torque mode
    float torque_limit = 9; // AMK inverter torque limit in use
}

message vn_gnss_comp_sig_health {
    int32 num_sats_pvt_1 = 1; // num of common satelites that are used in the PVT solution on receiver A
    int32 num_sats_rtk_1 = 2; // num of common satelites that are used in the RTK solution on receiver A
    float highest_cn0_1 = 3; // Highest CN0 reported on receiver A
    int32 num_sats_pvt_2 = 4; // num of common satelites that are used in the PVT solution on receiver B
    int32 num_sats_rtk_2 = 5; // num of common satelites that are used in the RTK solution on receiver B
    float highest_cn0_2 = 6; // Highest CN0 reported on receiver B
    int32 num_com_sats_pvt = 7; // num of common satelites that are used in the PVT solution on both receivers
    int32 num_com_sats_rtk = 8; // num of common satelites that are used in the RTK solution on both receivers
}

message drivetrain_command {
    float drivetrain_traj_torque_lim_fl = 1;
    float drivetrain_traj_torque_lim_fr = 2;
    float drivetrain_traj_torque_lim_rl = 3;
    float drivetrain_traj_torque_lim_rr = 4;
}

message drivetrain_filter_out_torque_tel {
    int32 fl_motor_torque = 1;
    int32 fr_motor_torque = 2;
    int32 rl_motor_torque = 3;
    int32 rr_motor_torque = 4;
}

message drivebrain_torque_lim_input {
    float drivebrain_torque_fl = 1;
    float drivebrain_torque_fr = 2;
    float drivebrain_torque_rl = 3;
    float drivebrain_torque_rr = 4;
}

message drivebrain_speed_set_input {
    int32 drivebrain_set_rpm_fl = 1;
    int32 drivebrain_set_rpm_fr = 2;
    int32 drivebrain_set_rpm_rl = 3;
    int32 drivebrain_set_rpm_rr = 4;
}

message brake_temps {
}

